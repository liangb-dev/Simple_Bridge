#!/usr/bin/env python
import sys
import socket
import time
import threading
import string
import getpass
import argparse
import struct

"""
Program: Bridge 
Arguments: bridge ID, arbitrary number of ports (int) (which also correspond to the
wires to be used)
usage: bridge <mac> <port1> <port2> ...
Description: Receives and sends BPDU messages across wires. Keep a table record of
             certain values from the received BPDU messages. 

===================================================================================
"""



"""
method: parseargs
Creates an object that takes in a mac address of format 'll:ll:ll:ll:ll:ll'
as well as an arbitrary number of ports numbers that also correspond to wire
numbers
"""
def parseargs():
    global args
    #Create ArgumentParser object
    parser = argparse.ArgumentParser(description='Bridge - recv/send BPDU')
    #Add argument option for
    parser.add_argument('ID', metavar = 'll:ll:ll:ll:ll:ll', type=str, nargs=1, help='Birgde ID')
    #Add argument option for arbitrary number of ports (int)
    parser.add_argument('ports', metavar='W', type=int, help='port/wire numbers', nargs="+")
    #Add argument option for '--silent'
    parser.add_argument('--silent', action='store_true',help='receive only, no transmit')
    #Assign values to variable 'args'
    args = parser.parse_args()


"""
method: ether_aton
'Replaces' all '-' for ':' in the argument, 
then convert all hex to decimal integers representation, 
then 'packs' each individual element and 'reduces' the array into a sum of elements
returns: sum
"""
def ether_aton(a):
    a = a.replace('-',':')
    b = map(lambda x: int(x,16), a.split(':')) #all numbers from hex to decimal
    return reduce(lambda x,y: x+y, map(lambda x: struct.pack('B', x), b))

"""
method: ether_ntoa
'Unpacks' each individual element and converts to 2 decimal places, 
then 'join' them into a string
returns: the string
"""
def ether_ntoa(n):
    return string.join(map(lambda x: "%02x" % x, struct.unpack('6B', n)), ':')

"""
Not sure what this does yet!!
"""
def receive(s):
    while True:
        dgram = s.recv(1500)
        if not dgram:
            print 'lost connection'
            sys.exit(1)
        dst,src = struct.unpack('6s 6s', dgram[0:12])
        print 'received dgram from %s to %s:' % (ether_ntoa(src), ether_ntoa(dst))
        print string.join(map(lambda x: '%02x' % ord(x), buffer(dgram)[:]), ' ')
        print ''

"""
vector V[p] = <R,c,T,p,age> where:
R = root port identifier from last received BPDU
c = root cost (hops weighted by link speed) from last BPDU
T = the switch that sent the last received BPDU
p = port ID on sending switch
age = age of message
"""
class Vector(object):
    def __init__(self, port):
        self.R = port;
        self.c = 0;
        self.T = port;
        self.p = 0;
        self.age = 0;

    def __init__(self, R=None, c=0, T=None, p=0, age=0):
        self.R = R
        self.c = c
        self.T = T
        self.p = p
        self.age = age

    # return true if this vector is better than the other
    def is_better_than(self, b2) :
        return ((self.R < b2.R) or
            ((self.R==b2.R) and (self.c<b2.c)) or
            ((self.R==b2.R) and (self.c==b2.c) and (self.T<b2.T)) or
            ((self.R==b2.R) and (self.c==b2.c) and (self.T==b2.T)
             and (self.p<b2.p)))


class Port(object):

    def __init__(self, portNo):
        self.my_bpdu = Vector(self)
        self.port_no = portNo
        self.logical_state = 'Designated'
        self.fwding_state = 'Listening'
        self.V = []
        self.bridge_bpdu = self.my_bpdu
        self.root_port = -1

    def best_v(self):
        best = self.V[0]
        for v in self.V:
            if v.is_better_than(best):
                best = v
        return best

    #def update_vector(self, bpdu_received):
    #    self.V[bpdu_received.p] = bpdu_received
    #    if self.bridge_bpdu.is_better_than(bpdu_received):
    #        self.bridge_bpdu == bpdu_received

    def spanning_tree(self, bpdu_received):
        bv = self.best_v()
        if bv == self.bridge_bpdu:
            return False
        if bv.is_better_than(self.bridge_bpdu):
            self.bridge_bpdu = bv
            # TODO: root_port = port bv rcvd on (i.e. V[root_port] == bv)
        if self.root_port != -1:
            self.root_port = -1
            self.logical_state = 'listening'
            # TODO: timer = 15




class Bridge(object):

    def __init__(self, bridgeId, portNos):
        self.bridgeId = bridgeId
        self.ports = {}
        self.bpdu = Vector(self)
        self.best_bpdu = Vector(self)

        for portNo in portNos:
            self.ports.append(Port(portNo))

    def broadcast_bpdu(self):
        for port in self.ports:
            # port.socket.send(bpdu)
            pass

    def update_bpdu(self):
        if self.best_bpdu.R != self.bpdu.R:
            self.bpdu.R = self.best_bpdu.R
        self.BPDU.cost = self.bestBPDU.cost + 1
        self.broadcastBPDU()





"""
Main function
"""
if __name__ == '__main__':
    parseargs()
    myID = ether_aton(args.ID[0])
    ports = args.ports
    wirenum = ports[0]

    remote = ether_aton("11:11:11:11:11:11")

    print "Bridge ID: ",myID
    print "Ports: ", ports
    print "Number of ports: ",len(ports)
    
    s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
    s.bind('\0%s.host-%s (wire %d)' % (getpass.getuser(), ether_ntoa(myID), wirenum))    
    if s.connect_ex('\0%s.wire.%d' % (getpass.getuser(), wirenum)):
        print 'connection error'
        sys.exit(1)
    
    t = threading.Thread(target=receive, args=[s])
    t.daemon = True     #so ^C works
    t.start()

    pkt_data = string.join(map(chr, (0xDE,0xAD,0xBE,0xEF,0xAD,0xBE,0xEF)), '')
    bogus_ethertype = 0x900
    pkt = struct.pack('!6s 6s H', remote, myID, bogus_ethertype) + pkt_data
    if len(pkt) < 60:
        pkt = pkt + '\0' * (60-len(pkt))
    
    while True:
        time.sleep(3)
        if not args.silent:
             s.send(pkt)



"""
BPDU - BPDU + localport#
    A<B iff a.priority < b.priority (a,b are roots)
         or
    A==B if  A!<B and B!<A

"""

