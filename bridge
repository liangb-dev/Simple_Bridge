#!/usr/bin/env python
import sys
import socket
import time
import threading
import string
import getpass
import argparse
import struct

"""
Program: Bridge 
Arguments: bridge ID, arbitrary number of ports (int) (which also correspond to the
wires to be used)
usage: bridge <mac> <port1> <port2> ...
Description: Receives and sends BPDU messages across wires. Keep a table record of
             certain values from the received BPDU messages. 

===================================================================================
"""



"""
method: parseargs
Creates an object that takes in a mac address of format 'll:ll:ll:ll:ll:ll'
as well as an arbitrary number of ports numbers that also correspond to wire
numbers
"""
def parseargs():
    global args
    #Create ArgumentParser object
    parser = argparse.ArgumentParser(description='Bridge - recv/send BPDU')
    #Add argument option for
    parser.add_argument('ID', metavar = 'll:ll:ll:ll:ll:ll', type=str, nargs=1, help='Birgde ID')
    #Add argument option for arbitrary number of ports (int)
    parser.add_argument('ports', metavar='W', type=int, help='port/wire numbers', nargs="+")
    #Add argument option for '--silent'
    parser.add_argument('--silent', action='store_true',help='receive only, no transmit')
    #Assign values to variable 'args'
    args = parser.parse_args()


"""
method: ether_aton
'Replaces' all '-' for ':' in the argument, 
then convert all hex to decimal integers representation, 
then 'packs' each individual element and 'reduces' the array into a sum of elements
returns: sum
"""
def ether_aton(a):
    a = a.replace('-',':')
    b = map(lambda x: int(x,16), a.split(':')) #all numbers from hex to decimal
    return reduce(lambda x,y: x+y, map(lambda x: struct.pack('B', x), b))

"""
method: ether_ntoa
'Unpacks' each individual element and converts to 2 decimal places, 
then 'join' them into a string
returns: the string
"""
def ether_ntoa(n):
    return string.join(map(lambda x: "%02x" % x, struct.unpack('6B', n)), ':')

"""
Not sure what this does yet!!
"""
def receive(s):
    while True:
        dgram = s.recv(1500)
        if not dgram:
            print 'lost connection'
            sys.exit(1)
        dst,src = struct.unpack('6s 6s', dgram[0:12])
        print 'received dgram from %s to %s:' % (ether_ntoa(src), ether_ntoa(dst))
        print string.join(map(lambda x: '%02x' % ord(x), buffer(dgram)[:]), ' ')
        print ''

"""
vector V[p] = <R,c,T,p,age> where:
R = root port identifier from last received BPDU
c = root cost (hops weighted by link speed) from last BPDU
T = the switch that sent the last received BPDU
p = port ID on sending switch
age = age of message
"""
class Vector(object):
    def __init__(self, port):
        self.R = port; # root port identifier from last received BPDU
        self.c = 0; # root cost from last BPDU
        self.T = port; # the switch that sent the last received BPDU
        self.p = 0; # port ID on sending switch
        self.age = 0; # age of message

    def __init__(self, R=None, c=0, T=None, p=0, age=0):
        self.R = R
        self.c = c
        self.T = T
        self.p = p
        self.age = age

"""
The bridge itself
"""
class Bridge(object):

    def __init__(self, bridge_id, ports):
        self.my_mac = my_mac #Constant
        self.my_bpdu = Vector(self) #Constant
        
        self.port_nums = []
        self.port_logical = []
        self.port_fwrd = []
        self.V = []
        self.timer = []
        
        self.bpdus = []
        self.best_bpdu = self.my_bpdu
        self.root_port = -1
        self.fwrd_table = {}

        #Initialize all ports
        for c in ports:
            self.port_nums.append(c) #Append port nums
            self.port_logical.append("Designated") #Append port logical states - default
            self.port_fwrd.append("Listening") #Append port forwarding states - default

        #Initialize forwarding table
        for c in ports:
            fwrd_table[c] = ["", 0] #[MAC,timer]
        #TODO: remove entry from the table if >15s

        #Initialize the vectors
        for c in ports:
            V.append(my_bpdu))
        

    #When you receive an ethernet packet on port 'portnum'
    def receive_packet():
        #if (portnum is not "Learning" nor "Forwarding"):
            #Drop it
        #Else:
            #extract source MAC Address
            #fwrd_table[portnum] = [src_mac, timer=0]
            #if (portnum is in "Forwading"):
                #extract the destination MAC address
                #if (dst_mac == 01:80:c2:00:00:00):
                    #drop it
                #else:
                    #if (check_table(dst_mac, portnum) and portnum is in "Forwarding"):
                        #Foward to corresponding portnum
                    #else:
                        #broadcast to all ports that arent portnum and that are in "Forwarding"


    #When you receive a new BPDU
    def newbpdu_updates(self, bpdu):
        #update per-port vector
        self.handle_vector(bpdu, recv_port) #TODO: Pass it a real recv_port
        #update port states
        handle_vector(bpdu, recv_port) 
        

    #Update per-port vector
    def handle_vector(self, bpdu, portNo):
        vector = self.port_nums[portNo]
        vector.c += 10
        vector.a += 1
        
        #a) compare my_bpdu to received vector
        #   if vector is better than bpdu
        if (self.compare_bpdu(bpdu, vector)): 
            my_bpdu = vector
        

    #Update port states
    def update_port(self, vector): 
        #b) received port becomes root port
        self.root_port = vector.R
        #c) all ports j where V[j] is worse than bridge BPDU become Designated
        for index in len(ports):
            if (self.compare_bpdu(bpdu, v):
                self.port_logical[index] = "Designated"
                self.port_fwrd[index] = "Listening"
                #TODO: Set timer to 15s for this port
            else:
                self.port_logical[index] = "Blocked"
                #TODO: Set timer to 0s for this port

#TODO: When a port timer fires in Listening state you set it to 15s and change to Learning state
#TODO: When a port timer fires in Learning state you set it to 0s and change to Forwarding state


    def spanning_tree(self):
        bv = self.best_v()
        if bv == self.bridge_bpdu:
            return False
        if bv.is_better_than(self.bridge_bpdu):
            self.bridge_bpdu = bv
            # TODO: root_port = port bv rcvd on (i.e. V[root_port] == bv)
        if self.root_port != -1:
            self.root_port = -1
            self.logical_state = 'listening'
            # TODO: timer = 15

    # update the status of all the 'Port' in 'self.ports'
    def update_ports(self):
        pass
    
    # update the forwarding table
    def update_table(self, portnum, mac):
        self.fwrd_table.update({portnum:mac})
    
    # check to see if destination is in table
    def check_fwrd_table(self, mac):
        return mac in self.fwrd_table.values() 

    # get port logical status
    def get_logical(self, portnum):
        index = port_nums.index(portnum)
        return port_logical[index]
    # get port forwarding status
    def get_fwrd(self, portnum):
        index = port_nums.index(portnum)
        return port_fwrd[index]

    # send on port
    def send_on_port(self, portnum): #Arg: Takes in a 'Port'
        if (get_logical(portnum) != "Blocked"):
            pass
            # TODO: Send self.bpdu on 'Port'
        else:
            pass
            

    # send out self.bpdu    
    def broadcast_bpdu(self):
        if (self.check_fwrd_table()): #Return True if Destination is in Forwarding Table
            send_on_port(self.fwrd_table['dest']) #TODO: insert 'destination'
        else: #if Destination is not in Forwarding Table
            for c in self.ports: #TODO: ignore the receiving port?
                send_on_port(c) 
                    
         
    # return true if this vector is better than the other
    def compare_bpdu(self, b1, b2) :
        return ((b1.R < b2.R) or
            ((b1.R==b2.R) and (b1.c<b2.c)) or
            ((b1.R==b2.R) and (b1.c==b2.c) and (b1.T<b2.T)) or
            ((b1.R==b2.R) and (b1.c==b2.c) and (b1.T==b2.T)
             and (b1.p<b2.p)))



"""
Main function
"""
if __name__ == '__main__':
    parseargs()
    
    myID = ether_aton(args.ID[0])
    ports = args.ports
    bridge = Bridge(myID, ports)
    
    remote = ether_aton("11:11:11:11:11:11")

    print "Bridge ID: ", ether_ntoa(myID)
    print "Ports: ", bridge.ports
    print "Number of ports: ",len(ports)

    for wirenum in bridge.ports: #Do for every port 
        s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        s.bind('\0%s.host-%s (wire %d)' % (getpass.getuser(), ether_ntoa(bridge.my_mac), wirenum))    
        if s.connect_ex('\0%s.wire.%d' % (getpass.getuser(), wirenum)):
            print 'connection error'
            sys.exit(1)
    
        t = threading.Thread(target=receive, args=[s])
        t.daemon = True     #so ^C works
        t.start()

        pkt_data = string.join(map(chr, (0xDE,0xAD,0xBE,0xEF,0xAD,0xBE,0xEF)), '')
        bogus_ethertype = 0x900
        pkt = struct.pack('!6s 6s H', remote, myID, bogus_ethertype) + pkt_data
        if len(pkt) < 60:
            pkt = pkt + '\0' * (60-len(pkt))
    
        while True:
            time.sleep(3)
            if not args.silent:
                s.send(pkt)


