#!/usr/bin/env python
import sys
import socket
import time
import threading
import string
import getpass
import argparse
import struct

"""
Program: Bridge 
Arguments: bridge ID, arbitrary number of ports (int) (which also correspond to the
wires to be used)
usage: bridge <mac> <port1> <port2> ...
Description: Receives and sends BPDU messages across wires. Keep a table record of
             certain values from the received BPDU messages. 

===================================================================================
"""



"""
method: parseargs
Creates an object that takes in a mac address of format 'll:ll:ll:ll:ll:ll'
as well as an arbitrary number of ports numbers that also correspond to wire
numbers
"""
def parseargs():
    global args
    #Create ArgumentParser object
    parser = argparse.ArgumentParser(description='Bridge - recv/send BPDU')
    #Add argument option for
    parser.add_argument('ID', metavar = 'll:ll:ll:ll:ll:ll', type=str, nargs=1, help='Birgde ID')
    #Add argument option for arbitrary number of ports (int)
    parser.add_argument('ports', metavar='W', type=int, help='port/wire numbers', nargs="+")
    #Add argument option for '--silent'
    parser.add_argument('--silent', action='store_true',help='receive only, no transmit')
    #Assign values to variable 'args'
    args = parser.parse_args()


"""
method: ether_aton
'Replaces' all '-' for ':' in the argument, 
then convert all hex to decimal integers representation, 
then 'packs' each individual element and 'reduces' the array into a sum of elements
returns: sum
"""
def ether_aton(a):
    a = a.replace('-',':')
    b = map(lambda x: int(x,16), a.split(':')) #all numbers from hex to decimal
    return reduce(lambda x,y: x+y, map(lambda x: struct.pack('B', x), b))

"""
method: ether_ntoa
'Unpacks' each individual element and converts to 2 decimal places, 
then 'join' them into a string
returns: the string
"""
def ether_ntoa(n):
    return string.join(map(lambda x: "%02x" % x, struct.unpack('6B', n)), ':')

"""
Not sure what this does yet!!
"""
def receive(s):
    while True:
        dgram = s.recv(1500)
        if not dgram:
            print 'lost connection'
            sys.exit(1)
        dst,src = struct.unpack('6s 6s', dgram[0:12])
        print 'received dgram from %s to %s:' % (ether_ntoa(src), ether_ntoa(dst))
        print string.join(map(lambda x: '%02x' % ord(x), buffer(dgram)[:]), ' ')
        print ''

"""
vector V[p] = <R,c,T,p,age> where:
R = root port identifier from last received BPDU
c = root cost (hops weighted by link speed) from last BPDU
T = the switch that sent the last received BPDU
p = port ID on sending switch
age = age of message
"""
class Vector(object):
    def __init__(self, port):
        self.R = port;
        self.c = 0;
        self.T = port;
        self.p = 0;
        self.age = 0;

    def __init__(self, R=None, c=0, T=None, p=0, age=0):
        self.R = R
        self.c = c
        self.T = T
        self.p = p
        self.age = age

"""
The bridge itself
"""
class Bridge(object):

    def __init__(self, bridge_id, ports):
        self.my_mac = my_mac
        self.my_bpdu = Vector(self)
        self.ports = ports
        self.bpdus = []
        self.my_bpdu = Vector(self)
        self.best_bpdu = self.my_bpdu
        self.root_port = -1
        self.forwarding_table = {}

        for c in ports:
            self.ports.append(

        


    def receive_bpdu(self, bpdu, portNo):
        bpdu.c += 10
        bpdu.a += 1

    def spanning_tree(self):
        bv = self.best_v()
        if bv == self.bridge_bpdu:
            return False
        if bv.is_better_than(self.bridge_bpdu):
            self.bridge_bpdu = bv
            # TODO: root_port = port bv rcvd on (i.e. V[root_port] == bv)
        if self.root_port != -1:
            self.root_port = -1
            self.logical_state = 'listening'
            # TODO: timer = 15

    # update the status of all the 'Port' in 'self.ports'
    def update_ports(self):
        pass
    
    # update the forwarding table
    def update_table(self):
        pass
    
    # check to see if destination is in table
    def check_forwarding_table(self):
        return True
    
    # check the status of port 
    def check_port_status(self, Port): #Arg: Takes in a 'Port'
        return Port.logical_state != 'Blocked' #Return False if the port is 'blocked'

    # send on port
    def send_on_port(self, Port): #Arg: Takes in a 'Port'
        if (check_port_status(Port)):
            pass
            # TODO: Send self.bpdu on 'Port'
        else:
            pass
            

    # send out self.bpdu    
    def broadcast_bpdu(self):
        if (self.check_forwarding_table()): #Return True if Destination is in Forwarding Table
            send_on_port(self.forwarding_table['dest']) #TODO: insert 'destination'
        else: #if Destination is not in Forwarding Table
            for c in self.ports: #TODO: ignore the receiving port?
                send_on_port(c) 
                    
         
    # return true if this vector is better than the other
    def is_better_than(self, b1, b2) :
        return ((b1.R < b2.R) or
            ((b1.R==b2.R) and (b1.c<b2.c)) or
            ((b1.R==b2.R) and (b1.c==b2.c) and (b1.T<b2.T)) or
            ((b1.R==b2.R) and (b1.c==b2.c) and (b1.T==b2.T)
             and (b1.p<b2.p)))

        

"""
A port
"""
class Port(object):

    def __init__(self, portNo):
        self.my_bpdu = Vector(self)
        self.port_no = portNo
        self.logical_state = 'Designated'
        self.fwding_state = 'Listening'

    def outbound_delivery(self):
        pass

    def inbound_delivery(self):
        pass




"""
Main function
"""
if __name__ == '__main__':
    parseargs()
    
    myID = ether_aton(args.ID[0])
    ports = args.ports
    bridge = Bridge(myID, ports)
    #wirenum = ports[0]

    remote = ether_aton("11:11:11:11:11:11")

    print "Bridge ID: ", ether_ntoa(myID)
    print "Ports: ", bridge.ports
    print "Number of ports: ",len(ports)

    for wirenum in bridge.ports: #Do for every port 
        s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        s.bind('\0%s.host-%s (wire %d)' % (getpass.getuser(), ether_ntoa(bridge.my_mac), wirenum))    
        if s.connect_ex('\0%s.wire.%d' % (getpass.getuser(), wirenum)):
            print 'connection error'
            sys.exit(1)
    
        t = threading.Thread(target=receive, args=[s])
        t.daemon = True     #so ^C works
        t.start()

        pkt_data = string.join(map(chr, (0xDE,0xAD,0xBE,0xEF,0xAD,0xBE,0xEF)), '')
        bogus_ethertype = 0x900
        pkt = struct.pack('!6s 6s H', remote, myID, bogus_ethertype) + pkt_data
        if len(pkt) < 60:
            pkt = pkt + '\0' * (60-len(pkt))
    
        while True:
            time.sleep(3)
            if not args.silent:
                s.send(pkt)


